/**
 * Cached Forecast Data Loader
 *
 * Loads pre-downloaded forecast data for testing the forecast slider.
 * Data is generated by scripts/download-forecast-data.ts
 */

import * as fs from 'fs';
import * as path from 'path';

const DATA_FILE = path.join(process.cwd(), 'data', 'forecasts', 'forecast-data.json');

interface WaveDataPoint {
  lat: number;
  lon: number;
  waveHeight: number;
  waveDirection: number;
  wavePeriod: number;
}

interface WindDataPoint {
  lat: number;
  lon: number;
  u: number;
  v: number;
  speed: number;
  direction: number;
}

interface ForecastData {
  modelRun: string;
  generatedAt: string;
  forecastHours: number[];
  data: Record<string, { waves: WaveDataPoint[]; wind: WindDataPoint[] }>;
}

// Cache the loaded data in memory
let cachedData: ForecastData | null = null;
let cacheLoadTime = 0;
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

/**
 * Load cached forecast data from disk
 */
function loadCachedData(): ForecastData | null {
  const now = Date.now();

  // Return memory cache if still valid
  if (cachedData && (now - cacheLoadTime) < CACHE_TTL) {
    return cachedData;
  }

  // Check if file exists
  if (!fs.existsSync(DATA_FILE)) {
    console.log('No cached forecast data found at', DATA_FILE);
    return null;
  }

  try {
    const fileContent = fs.readFileSync(DATA_FILE, 'utf-8');
    cachedData = JSON.parse(fileContent);
    cacheLoadTime = now;
    console.log(`Loaded cached forecast data: ${cachedData?.forecastHours?.length} time steps`);
    return cachedData;
  } catch (err) {
    console.error('Error loading cached forecast data:', err);
    return null;
  }
}

/**
 * Find the closest available forecast hour
 */
function findClosestHour(requestedHour: number, availableHours: number[]): number {
  let closest = availableHours[0];
  let minDiff = Math.abs(requestedHour - closest);

  for (const hour of availableHours) {
    const diff = Math.abs(requestedHour - hour);
    if (diff < minDiff) {
      minDiff = diff;
      closest = hour;
    }
  }

  return closest;
}

/**
 * Get cached wave data for a specific forecast hour
 */
export function getCachedWaveData(forecastHour: number): WaveDataPoint[] | null {
  const data = loadCachedData();
  if (!data) return null;

  const closestHour = findClosestHour(forecastHour, data.forecastHours);
  const hourData = data.data[closestHour.toString()];

  if (!hourData?.waves) return null;

  console.log(`Using cached wave data for hour ${closestHour} (requested: ${forecastHour})`);
  return hourData.waves;
}

/**
 * Get cached wind data for a specific forecast hour
 */
export function getCachedWindData(forecastHour: number): WindDataPoint[] | null {
  const data = loadCachedData();
  if (!data) return null;

  const closestHour = findClosestHour(forecastHour, data.forecastHours);
  const hourData = data.data[closestHour.toString()];

  if (!hourData?.wind) return null;

  console.log(`Using cached wind data for hour ${closestHour} (requested: ${forecastHour})`);
  return hourData.wind;
}

/**
 * Get available forecast hours from cached data
 */
export function getAvailableForecastHours(): number[] {
  const data = loadCachedData();
  return data?.forecastHours || [0, 3, 6, 9, 12, 24, 48, 72, 96, 120];
}

/**
 * Get the model run time from cached data
 */
export function getCachedModelRun(): string | null {
  const data = loadCachedData();
  return data?.modelRun || null;
}

/**
 * Check if cached forecast data is available
 */
export function hasCachedForecastData(): boolean {
  return fs.existsSync(DATA_FILE);
}
