{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolaskaris/projects/sandbars/lib/supabase/server.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr'\nimport { cookies } from 'next/headers'\n\nexport async function createClient() {\n  const cookieStore = await cookies()\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) =>\n              cookieStore.set(name, value, options)\n            )\n          } catch {\n            // The `setAll` method was called from a Server Component.\n            // This can be ignored if you have middleware refreshing\n            // user sessions.\n          }\n        },\n      },\n    }\n  )\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IAEjC,OAAO,IAAA,iMAAkB,sUAGvB;QACE,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;gBAEjC,EAAE,OAAM;gBACN,0DAA0D;gBAC1D,wDAAwD;gBACxD,iBAAiB;gBACnB;YACF;QACF;IACF;AAEJ","debugId":null}},
    {"offset": {"line": 81, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolaskaris/projects/sandbars/lib/forecast/sources/ndbc.ts"],"sourcesContent":["/**\n * NDBC (National Data Buoy Center) Data Source\n * Fetches real-time buoy observations\n */\n\nimport { QualityFlag } from '@/types';\n\nconst NDBC_API_URL = 'https://www.ndbc.noaa.gov';\n\nexport interface NDBCBuoyReading {\n  timestamp: string;\n  waveHeight?: number;\n  dominantWavePeriod?: number;\n  averageWavePeriod?: number;\n  waveDirection?: number;\n  windSpeed?: number;\n  windDirection?: number;\n  waterTemperature?: number;\n  airTemperature?: number;\n  quality: QualityFlag;\n}\n\nexport interface NDBCBuoyInfo {\n  id: string;\n  lat: number;\n  lon: number;\n  name: string;\n}\n\n// Major NDBC buoy stations\nexport const NDBC_BUOYS: NDBCBuoyInfo[] = [\n  // California Coast\n  { id: '46221', lat: 33.8, lon: -118.3, name: 'Santa Monica Basin' },\n  { id: '46222', lat: 33.6, lon: -117.9, name: 'San Pedro' },\n  { id: '46232', lat: 37.5, lon: -122.5, name: 'Point Reyes' },\n  { id: '46237', lat: 37.8, lon: -122.4, name: 'San Francisco' },\n  { id: '46254', lat: 33.2, lon: -119.9, name: 'Ventura' },\n  { id: '46025', lat: 33.7, lon: -119.1, name: 'Santa Monica' },\n  { id: '46215', lat: 40.8, lon: -124.5, name: 'Cape Mendocino' },\n  { id: '46014', lat: 39.2, lon: -123.3, name: 'Point Arena' },\n  { id: '46026', lat: 37.8, lon: -122.8, name: 'San Francisco Bar' },\n  { id: '46012', lat: 37.4, lon: -122.9, name: 'Half Moon Bay' },\n  { id: '46042', lat: 36.8, lon: -122.4, name: 'Monterey Bay' },\n  { id: '46011', lat: 34.9, lon: -121.0, name: 'Santa Maria' },\n\n  // Hawaii\n  { id: '51201', lat: 24.4, lon: -162.1, name: 'Hanalei' },\n  { id: '51202', lat: 21.5, lon: -157.8, name: 'Waimea Bay' },\n\n  // East Coast\n  { id: '44025', lat: 40.3, lon: -73.2, name: 'Long Island' },\n  { id: '44065', lat: 40.4, lon: -73.7, name: 'New York Harbor' },\n  { id: '41010', lat: 28.9, lon: -78.5, name: 'Canaveral East' },\n  { id: '42040', lat: 29.2, lon: -88.2, name: 'Luke Offshore' },\n];\n\n/**\n * Check if a value is missing (NDBC missing data markers)\n */\nfunction isMissing(val: string | number | undefined): boolean {\n  if (val === undefined || val === null) return true;\n  const strVal = String(val);\n  return strVal === 'MM' || strVal === '999' || strVal === '999.0' || strVal === '99.0';\n}\n\n/**\n * Determine quality flag based on data freshness\n */\nfunction determineQuality(timestamp: Date): QualityFlag {\n  const age = Date.now() - timestamp.getTime();\n  const hoursOld = age / (1000 * 60 * 60);\n\n  if (hoursOld < 1) return 'primary';\n  if (hoursOld < 3) return 'primary';\n  return 'stale';\n}\n\n/**\n * Fetch current buoy data from NDBC\n */\nexport async function fetchNDBCBuoyData(buoyId: string): Promise<NDBCBuoyReading | null> {\n  try {\n    const response = await fetch(\n      `${NDBC_API_URL}/data/realtime2/${buoyId}.txt`,\n      {\n        next: { revalidate: 1800 }, // Cache for 30 minutes\n        headers: {\n          'User-Agent': '(Sandbars Surf App, contact@sandbars.app)',\n        },\n      }\n    );\n\n    if (!response.ok) {\n      console.error(`NDBC API error for buoy ${buoyId}: ${response.statusText}`);\n      return null;\n    }\n\n    const text = await response.text();\n    const lines = text.split('\\n');\n\n    // Parse the latest data (line 2, after header lines)\n    if (lines.length < 3) {\n      return null;\n    }\n\n    // NDBC format: YY MM DD hh mm WDIR WSPD GST WVHT DPD APD MWD PRES ATMP WTMP DEWP VIS TIDE\n    const data = lines[2].trim().split(/\\s+/);\n\n    if (data.length < 15) {\n      console.error(`NDBC buoy ${buoyId}: Insufficient data fields`);\n      return null;\n    }\n\n    // Parse timestamp\n    const year = parseInt(data[0]) + 2000; // YY format\n    const month = data[1];\n    const day = data[2];\n    const hour = data[3];\n    const minute = data[4];\n    const timestamp = new Date(`${year}-${month}-${day}T${hour}:${minute}:00Z`);\n\n    // Parse values\n    const waveHeight = parseFloat(data[8]); // WVHT - significant wave height (meters)\n    const dominantPeriod = parseFloat(data[9]); // DPD - dominant wave period (seconds)\n    const avgPeriod = parseFloat(data[10]); // APD - average wave period (seconds)\n    const waveDir = parseFloat(data[11]); // MWD - wave direction (degrees)\n    const windSpeed = parseFloat(data[6]); // WSPD - wind speed (m/s)\n    const windDir = parseFloat(data[5]); // WDIR - wind direction (degrees)\n    const airTemp = parseFloat(data[13]); // ATMP - air temperature (°C)\n    const waterTemp = parseFloat(data[14]); // WTMP - water temperature (°C)\n\n    const quality = determineQuality(timestamp);\n\n    return {\n      timestamp: timestamp.toISOString(),\n      waveHeight: !isNaN(waveHeight) && !isMissing(waveHeight) && waveHeight < 99 ? waveHeight : undefined,\n      dominantWavePeriod: !isNaN(dominantPeriod) && !isMissing(dominantPeriod) && dominantPeriod < 99 ? dominantPeriod : undefined,\n      averageWavePeriod: !isNaN(avgPeriod) && !isMissing(avgPeriod) && avgPeriod < 99 ? avgPeriod : undefined,\n      waveDirection: !isNaN(waveDir) && !isMissing(waveDir) && waveDir <= 360 ? waveDir : undefined,\n      windSpeed: !isNaN(windSpeed) && !isMissing(windSpeed) && windSpeed < 99 ? windSpeed : undefined,\n      windDirection: !isNaN(windDir) && !isMissing(windDir) && windDir <= 360 ? windDir : undefined,\n      airTemperature: !isNaN(airTemp) && !isMissing(airTemp) && airTemp < 99 ? airTemp : undefined,\n      waterTemperature: !isNaN(waterTemp) && !isMissing(waterTemp) && waterTemp < 99 ? waterTemp : undefined,\n      quality,\n    };\n  } catch (error) {\n    console.error(`Error fetching NDBC buoy ${buoyId}:`, error);\n    return null;\n  }\n}\n\n/**\n * Calculate distance between two coordinates (Haversine formula)\n */\nexport function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6371; // Earth's radius in km\n  const dLat = toRad(lat2 - lat1);\n  const dLon = toRad(lon2 - lon1);\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n}\n\nfunction toRad(degrees: number): number {\n  return degrees * (Math.PI / 180);\n}\n\n/**\n * Find nearest buoys to a location\n */\nexport function findNearestBuoys(\n  lat: number,\n  lon: number,\n  maxDistance: number = 200,\n  count: number = 5\n): NDBCBuoyInfo[] {\n  const buoysWithDistance = NDBC_BUOYS.map(buoy => ({\n    ...buoy,\n    distance: calculateDistance(lat, lon, buoy.lat, buoy.lon),\n  }));\n\n  return buoysWithDistance\n    .filter(b => b.distance < maxDistance)\n    .sort((a, b) => a.distance - b.distance)\n    .slice(0, count);\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 306, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolaskaris/projects/sandbars/lib/forecast/sources/nws.ts"],"sourcesContent":["/**\n * NOAA NWS (National Weather Service) Data Source\n * Fetches weather forecasts and air temperature\n */\n\nimport { QualityFlag } from '@/types';\n\nconst NWS_API_URL = 'https://api.weather.gov';\n\ninterface NWSGridpoint {\n  properties: {\n    forecast: string;\n    forecastHourly: string;\n    forecastGridData: string;\n  };\n}\n\nexport interface NWSForecastPeriod {\n  number: number;\n  name: string;\n  startTime: string;\n  endTime: string;\n  temperature: number;\n  temperatureUnit: string;\n  windSpeed: string;\n  windDirection: string;\n  shortForecast: string;\n  detailedForecast: string;\n}\n\nexport interface NWSWeatherData {\n  timestamp: string;\n  airTemperature?: number;\n  windSpeed?: number;\n  windDirection?: number;\n  quality: QualityFlag;\n}\n\n/**\n * Parse wind speed string from NWS (e.g., \"10 mph\", \"5 to 10 mph\")\n */\nexport function parseWindSpeed(windSpeedStr: string): number {\n  const match = windSpeedStr.match(/(\\d+)/);\n  if (!match) return 0;\n  const mph = parseInt(match[1]);\n  return mph * 0.44704; // Convert mph to m/s\n}\n\n/**\n * Parse wind direction to degrees\n */\nexport function parseWindDirection(dir: string): number {\n  const directions: { [key: string]: number } = {\n    N: 0,\n    NNE: 22.5,\n    NE: 45,\n    ENE: 67.5,\n    E: 90,\n    ESE: 112.5,\n    SE: 135,\n    SSE: 157.5,\n    S: 180,\n    SSW: 202.5,\n    SW: 225,\n    WSW: 247.5,\n    W: 270,\n    WNW: 292.5,\n    NW: 315,\n    NNW: 337.5,\n  };\n  return directions[dir.toUpperCase()] || 0;\n}\n\n/**\n * Get NOAA NWS forecast for a location\n */\nexport async function fetchNWSForecast(\n  lat: number,\n  lng: number\n): Promise<NWSForecastPeriod[]> {\n  try {\n    // Step 1: Get the grid point for the coordinates\n    const pointResponse = await fetch(\n      `${NWS_API_URL}/points/${lat.toFixed(4)},${lng.toFixed(4)}`,\n      {\n        headers: {\n          'User-Agent': '(Sandbars Surf App, contact@sandbars.app)',\n        },\n        next: { revalidate: 3600 }, // Cache for 1 hour\n      }\n    );\n\n    if (!pointResponse.ok) {\n      console.error(`NWS points API error: ${pointResponse.statusText}`);\n      return [];\n    }\n\n    const pointData: NWSGridpoint = await pointResponse.json();\n\n    // Step 2: Get the hourly forecast\n    const forecastResponse = await fetch(pointData.properties.forecastHourly, {\n      headers: {\n        'User-Agent': '(Sandbars Surf App, contact@sandbars.app)',\n      },\n      next: { revalidate: 1800 }, // Cache for 30 minutes\n    });\n\n    if (!forecastResponse.ok) {\n      console.error(`NWS forecast API error: ${forecastResponse.statusText}`);\n      return [];\n    }\n\n    const forecastData = await forecastResponse.json();\n    return forecastData.properties.periods || [];\n  } catch (error) {\n    console.error('Error fetching NWS forecast:', error);\n    return [];\n  }\n}\n\n/**\n * Convert NWS forecast periods to weather data array\n */\nexport function convertNWSToWeatherData(\n  periods: NWSForecastPeriod[]\n): NWSWeatherData[] {\n  return periods.map(period => ({\n    timestamp: period.startTime,\n    airTemperature:\n      period.temperatureUnit === 'F'\n        ? ((period.temperature - 32) * 5) / 9 // Convert to Celsius\n        : period.temperature,\n    windSpeed: parseWindSpeed(period.windSpeed),\n    windDirection: parseWindDirection(period.windDirection),\n    quality: 'primary' as QualityFlag,\n  }));\n}\n\n/**\n * Get weather data for a specific time\n */\nexport function getWeatherAtTime(\n  weatherData: NWSWeatherData[],\n  targetTime: Date\n): NWSWeatherData | null {\n  const targetTimestamp = targetTime.getTime();\n\n  // Find the closest forecast period\n  let closest: NWSWeatherData | null = null;\n  let minDiff = Infinity;\n\n  for (const data of weatherData) {\n    const dataTimestamp = new Date(data.timestamp).getTime();\n    const diff = Math.abs(dataTimestamp - targetTimestamp);\n\n    if (diff < minDiff) {\n      minDiff = diff;\n      closest = data;\n    }\n  }\n\n  // Only return if within 3 hours\n  if (minDiff < 3 * 60 * 60 * 1000) {\n    return closest;\n  }\n\n  return null;\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;AAID,MAAM,cAAc;AAkCb,SAAS,eAAe,YAAoB;IACjD,MAAM,QAAQ,aAAa,KAAK,CAAC;IACjC,IAAI,CAAC,OAAO,OAAO;IACnB,MAAM,MAAM,SAAS,KAAK,CAAC,EAAE;IAC7B,OAAO,MAAM,SAAS,qBAAqB;AAC7C;AAKO,SAAS,mBAAmB,GAAW;IAC5C,MAAM,aAAwC;QAC5C,GAAG;QACH,KAAK;QACL,IAAI;QACJ,KAAK;QACL,GAAG;QACH,KAAK;QACL,IAAI;QACJ,KAAK;QACL,GAAG;QACH,KAAK;QACL,IAAI;QACJ,KAAK;QACL,GAAG;QACH,KAAK;QACL,IAAI;QACJ,KAAK;IACP;IACA,OAAO,UAAU,CAAC,IAAI,WAAW,GAAG,IAAI;AAC1C;AAKO,eAAe,iBACpB,GAAW,EACX,GAAW;IAEX,IAAI;QACF,iDAAiD;QACjD,MAAM,gBAAgB,MAAM,MAC1B,GAAG,YAAY,QAAQ,EAAE,IAAI,OAAO,CAAC,GAAG,CAAC,EAAE,IAAI,OAAO,CAAC,IAAI,EAC3D;YACE,SAAS;gBACP,cAAc;YAChB;YACA,MAAM;gBAAE,YAAY;YAAK;QAC3B;QAGF,IAAI,CAAC,cAAc,EAAE,EAAE;YACrB,QAAQ,KAAK,CAAC,CAAC,sBAAsB,EAAE,cAAc,UAAU,EAAE;YACjE,OAAO,EAAE;QACX;QAEA,MAAM,YAA0B,MAAM,cAAc,IAAI;QAExD,kCAAkC;QAClC,MAAM,mBAAmB,MAAM,MAAM,UAAU,UAAU,CAAC,cAAc,EAAE;YACxE,SAAS;gBACP,cAAc;YAChB;YACA,MAAM;gBAAE,YAAY;YAAK;QAC3B;QAEA,IAAI,CAAC,iBAAiB,EAAE,EAAE;YACxB,QAAQ,KAAK,CAAC,CAAC,wBAAwB,EAAE,iBAAiB,UAAU,EAAE;YACtE,OAAO,EAAE;QACX;QAEA,MAAM,eAAe,MAAM,iBAAiB,IAAI;QAChD,OAAO,aAAa,UAAU,CAAC,OAAO,IAAI,EAAE;IAC9C,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO,EAAE;IACX;AACF;AAKO,SAAS,wBACd,OAA4B;IAE5B,OAAO,QAAQ,GAAG,CAAC,CAAA,SAAU,CAAC;YAC5B,WAAW,OAAO,SAAS;YAC3B,gBACE,OAAO,eAAe,KAAK,MACvB,AAAC,CAAC,OAAO,WAAW,GAAG,EAAE,IAAI,IAAK,EAAE,qBAAqB;eACzD,OAAO,WAAW;YACxB,WAAW,eAAe,OAAO,SAAS;YAC1C,eAAe,mBAAmB,OAAO,aAAa;YACtD,SAAS;QACX,CAAC;AACH;AAKO,SAAS,iBACd,WAA6B,EAC7B,UAAgB;IAEhB,MAAM,kBAAkB,WAAW,OAAO;IAE1C,mCAAmC;IACnC,IAAI,UAAiC;IACrC,IAAI,UAAU;IAEd,KAAK,MAAM,QAAQ,YAAa;QAC9B,MAAM,gBAAgB,IAAI,KAAK,KAAK,SAAS,EAAE,OAAO;QACtD,MAAM,OAAO,KAAK,GAAG,CAAC,gBAAgB;QAEtC,IAAI,OAAO,SAAS;YAClB,UAAU;YACV,UAAU;QACZ;IACF;IAEA,gCAAgC;IAChC,IAAI,UAAU,IAAI,KAAK,KAAK,MAAM;QAChC,OAAO;IACT;IAEA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 418, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolaskaris/projects/sandbars/lib/forecast/sources/tides.ts"],"sourcesContent":["/**\n * NOAA Tides & Currents Data Source\n * Fetches tide predictions\n */\n\nimport { QualityFlag } from '@/types';\n\nconst TIDES_API_URL = 'https://api.tidesandcurrents.noaa.gov/api/prod/datagetter';\n\nexport interface TideStation {\n  id: string;\n  name: string;\n  lat: number;\n  lon: number;\n}\n\nexport interface TidePrediction {\n  timestamp: string;\n  tideLevel: number; // meters\n  quality: QualityFlag;\n}\n\n// Major tide stations (can be expanded)\nexport const TIDE_STATIONS: TideStation[] = [\n  // California\n  { id: '9410170', name: 'San Diego Bay', lat: 32.7, lon: -117.2 },\n  { id: '9410840', name: 'La Jolla', lat: 32.9, lon: -117.3 },\n  { id: '9411340', name: 'Santa Monica', lat: 34.0, lon: -118.5 },\n  { id: '9414290', name: 'San Francisco', lat: 37.8, lon: -122.5 },\n  { id: '9413450', name: 'Monterey', lat: 36.6, lon: -121.9 },\n\n  // Hawaii\n  { id: '1612340', name: 'Honolulu', lat: 21.3, lon: -157.9 },\n  { id: '1615680', name: 'Hilo', lat: 19.7, lon: -155.1 },\n\n  // East Coast\n  { id: '8518750', name: 'The Battery, NY', lat: 40.7, lon: -74.0 },\n  { id: '8534720', name: 'Atlantic City', lat: 39.4, lon: -74.4 },\n  { id: '8721164', name: 'Miami Beach', lat: 25.8, lon: -80.1 },\n];\n\n/**\n * Calculate distance between two coordinates\n */\nfunction calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6371; // Earth's radius in km\n  const dLat = toRad(lat2 - lat1);\n  const dLon = toRad(lon2 - lon1);\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n}\n\nfunction toRad(degrees: number): number {\n  return degrees * (Math.PI / 180);\n}\n\n/**\n * Find nearest tide station\n */\nexport function findNearestTideStation(lat: number, lon: number): TideStation | null {\n  let nearest: TideStation | null = null;\n  let minDistance = Infinity;\n\n  for (const station of TIDE_STATIONS) {\n    const distance = calculateDistance(lat, lon, station.lat, station.lon);\n    if (distance < minDistance) {\n      minDistance = distance;\n      nearest = station;\n    }\n  }\n\n  // Only return if within reasonable distance (< 100km)\n  return minDistance < 100 ? nearest : null;\n}\n\n/**\n * Fetch tide predictions for a station\n */\nexport async function fetchTidePredictions(\n  stationId: string,\n  startDate: Date,\n  endDate: Date\n): Promise<TidePrediction[]> {\n  try {\n    const beginDate = formatDate(startDate);\n    const endDateStr = formatDate(endDate);\n\n    const params = new URLSearchParams({\n      product: 'predictions',\n      application: 'Sandbars',\n      begin_date: beginDate,\n      end_date: endDateStr,\n      datum: 'MLLW', // Mean Lower Low Water\n      station: stationId,\n      time_zone: 'gmt',\n      units: 'metric',\n      interval: 'h', // Hourly\n      format: 'json',\n    });\n\n    const response = await fetch(`${TIDES_API_URL}?${params.toString()}`, {\n      next: { revalidate: 86400 }, // Cache for 24 hours (predictions are static)\n    });\n\n    if (!response.ok) {\n      console.error(`Tides API error for station ${stationId}: ${response.statusText}`);\n      return [];\n    }\n\n    const data = await response.json();\n\n    if (!data.predictions || !Array.isArray(data.predictions)) {\n      return [];\n    }\n\n    return data.predictions.map((pred: any) => ({\n      timestamp: pred.t,\n      tideLevel: parseFloat(pred.v),\n      quality: 'primary' as QualityFlag,\n    }));\n  } catch (error) {\n    console.error(`Error fetching tide predictions for station ${stationId}:`, error);\n    return [];\n  }\n}\n\n/**\n * Format date for API (yyyyMMdd HH:mm)\n */\nfunction formatDate(date: Date): string {\n  const year = date.getUTCFullYear();\n  const month = String(date.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(date.getUTCDate()).padStart(2, '0');\n  const hours = String(date.getUTCHours()).padStart(2, '0');\n  const minutes = String(date.getUTCMinutes()).padStart(2, '0');\n  return `${year}${month}${day} ${hours}:${minutes}`;\n}\n\n/**\n * Get tide level at specific time\n */\nexport function getTideAtTime(\n  predictions: TidePrediction[],\n  targetTime: Date\n): TidePrediction | null {\n  const targetTimestamp = targetTime.getTime();\n\n  // Find closest prediction\n  let closest: TidePrediction | null = null;\n  let minDiff = Infinity;\n\n  for (const pred of predictions) {\n    const predTimestamp = new Date(pred.timestamp).getTime();\n    const diff = Math.abs(predTimestamp - targetTimestamp);\n\n    if (diff < minDiff) {\n      minDiff = diff;\n      closest = pred;\n    }\n  }\n\n  // Only return if within 1 hour\n  if (minDiff < 60 * 60 * 1000) {\n    return closest;\n  }\n\n  return null;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 595, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolaskaris/projects/sandbars/lib/forecast/interpolation.ts"],"sourcesContent":["/**\n * Spatial Interpolation Module\n * Implements Inverse Distance Weighting (IDW) for multi-source data\n */\n\nimport { QualityFlag } from '@/types';\n\nexport interface DataPoint {\n  value: number;\n  distance: number; // kilometers\n  quality: QualityFlag;\n}\n\n/**\n * Inverse Distance Weighting (IDW) interpolation\n * Weight = 1 / distance^power\n *\n * @param dataPoints - Array of data points with values and distances\n * @param power - Power parameter (default 2)\n * @param maxDistance - Maximum distance to consider (km)\n * @returns Interpolated value or null if no valid data\n */\nexport function inverseDistanceWeighting(\n  dataPoints: DataPoint[],\n  power: number = 2,\n  maxDistance: number = 100\n): { value: number; quality: QualityFlag } | null {\n  // Filter out invalid data points\n  const validPoints = dataPoints.filter(\n    p => p.distance <= maxDistance && !isNaN(p.value) && p.value !== null\n  );\n\n  if (validPoints.length === 0) {\n    return null;\n  }\n\n  // If we have a very close point (< 1km), just use it\n  const veryClose = validPoints.find(p => p.distance < 1);\n  if (veryClose) {\n    return { value: veryClose.value, quality: veryClose.quality };\n  }\n\n  // If only one point, return it\n  if (validPoints.length === 1) {\n    return { value: validPoints[0].value, quality: validPoints[0].quality };\n  }\n\n  // Calculate weights\n  let weightedSum = 0;\n  let weightSum = 0;\n\n  for (const point of validPoints) {\n    const weight = 1 / Math.pow(point.distance, power);\n    weightedSum += point.value * weight;\n    weightSum += weight;\n  }\n\n  const interpolatedValue = weightedSum / weightSum;\n\n  // Determine quality based on sources\n  const hasPrimary = validPoints.some(p => p.quality === 'primary');\n  const quality: QualityFlag = hasPrimary ? 'interpolated' : 'modeled';\n\n  return { value: interpolatedValue, quality };\n}\n\n/**\n * Temporal interpolation between two values\n */\nexport function temporalInterpolation(\n  value1: number,\n  time1: Date,\n  value2: number,\n  time2: Date,\n  targetTime: Date\n): number {\n  const t1 = time1.getTime();\n  const t2 = time2.getTime();\n  const target = targetTime.getTime();\n\n  // Linear interpolation\n  const ratio = (target - t1) / (t2 - t1);\n  return value1 + (value2 - value1) * ratio;\n}\n\n/**\n * Interpolate between buoys accounting for bathymetry\n * Uses standard IDW but with distance-based weighting that considers\n * coastal effects (closer to shore = more variable conditions)\n */\nexport function interpolateWaveData(\n  dataPoints: DataPoint[],\n  distanceToShore: number // km\n): { value: number; quality: QualityFlag } | null {\n  // For wave data, use higher power near shore (more local variation)\n  const power = distanceToShore < 10 ? 3 : 2;\n  const maxDistance = distanceToShore < 10 ? 50 : 100;\n\n  return inverseDistanceWeighting(dataPoints, power, maxDistance);\n}\n\n/**\n * Interpolate wind data with caution near coastlines\n */\nexport function interpolateWindData(\n  dataPoints: DataPoint[],\n  distanceToShore: number // km\n): { value: number; quality: QualityFlag } | null {\n  // Wind is less reliable near coastline due to land/sea effects\n  if (distanceToShore < 5) {\n    // Only use very close stations near shore\n    const closePoints = dataPoints.filter(p => p.distance < 20);\n    if (closePoints.length === 0) {\n      return null;\n    }\n    return inverseDistanceWeighting(closePoints, 2, 20);\n  }\n\n  return inverseDistanceWeighting(dataPoints, 2, 50);\n}\n\n/**\n * Simple averaging for slowly-changing variables like water temperature\n */\nexport function interpolateSlowVariable(\n  dataPoints: DataPoint[],\n  maxAge: number = 24 * 60 * 60 * 1000 // 24 hours in ms\n): { value: number; quality: QualityFlag } | null {\n  const validPoints = dataPoints.filter(\n    p => !isNaN(p.value) && p.value !== null && p.distance < 200\n  );\n\n  if (validPoints.length === 0) {\n    return null;\n  }\n\n  // Simple average for slow variables\n  const sum = validPoints.reduce((acc, p) => acc + p.value, 0);\n  const avg = sum / validPoints.length;\n\n  return { value: avg, quality: 'interpolated' };\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;AAmBM,SAAS,yBACd,UAAuB,EACvB,QAAgB,CAAC,EACjB,cAAsB,GAAG;IAEzB,iCAAiC;IACjC,MAAM,cAAc,WAAW,MAAM,CACnC,CAAA,IAAK,EAAE,QAAQ,IAAI,eAAe,CAAC,MAAM,EAAE,KAAK,KAAK,EAAE,KAAK,KAAK;IAGnE,IAAI,YAAY,MAAM,KAAK,GAAG;QAC5B,OAAO;IACT;IAEA,qDAAqD;IACrD,MAAM,YAAY,YAAY,IAAI,CAAC,CAAA,IAAK,EAAE,QAAQ,GAAG;IACrD,IAAI,WAAW;QACb,OAAO;YAAE,OAAO,UAAU,KAAK;YAAE,SAAS,UAAU,OAAO;QAAC;IAC9D;IAEA,+BAA+B;IAC/B,IAAI,YAAY,MAAM,KAAK,GAAG;QAC5B,OAAO;YAAE,OAAO,WAAW,CAAC,EAAE,CAAC,KAAK;YAAE,SAAS,WAAW,CAAC,EAAE,CAAC,OAAO;QAAC;IACxE;IAEA,oBAAoB;IACpB,IAAI,cAAc;IAClB,IAAI,YAAY;IAEhB,KAAK,MAAM,SAAS,YAAa;QAC/B,MAAM,SAAS,IAAI,KAAK,GAAG,CAAC,MAAM,QAAQ,EAAE;QAC5C,eAAe,MAAM,KAAK,GAAG;QAC7B,aAAa;IACf;IAEA,MAAM,oBAAoB,cAAc;IAExC,qCAAqC;IACrC,MAAM,aAAa,YAAY,IAAI,CAAC,CAAA,IAAK,EAAE,OAAO,KAAK;IACvD,MAAM,UAAuB,aAAa,iBAAiB;IAE3D,OAAO;QAAE,OAAO;QAAmB;IAAQ;AAC7C;AAKO,SAAS,sBACd,MAAc,EACd,KAAW,EACX,MAAc,EACd,KAAW,EACX,UAAgB;IAEhB,MAAM,KAAK,MAAM,OAAO;IACxB,MAAM,KAAK,MAAM,OAAO;IACxB,MAAM,SAAS,WAAW,OAAO;IAEjC,uBAAuB;IACvB,MAAM,QAAQ,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,EAAE;IACtC,OAAO,SAAS,CAAC,SAAS,MAAM,IAAI;AACtC;AAOO,SAAS,oBACd,UAAuB,EACvB,eAAuB,AAAC,KAAK;;IAE7B,oEAAoE;IACpE,MAAM,QAAQ,kBAAkB,KAAK,IAAI;IACzC,MAAM,cAAc,kBAAkB,KAAK,KAAK;IAEhD,OAAO,yBAAyB,YAAY,OAAO;AACrD;AAKO,SAAS,oBACd,UAAuB,EACvB,eAAuB,AAAC,KAAK;;IAE7B,+DAA+D;IAC/D,IAAI,kBAAkB,GAAG;QACvB,0CAA0C;QAC1C,MAAM,cAAc,WAAW,MAAM,CAAC,CAAA,IAAK,EAAE,QAAQ,GAAG;QACxD,IAAI,YAAY,MAAM,KAAK,GAAG;YAC5B,OAAO;QACT;QACA,OAAO,yBAAyB,aAAa,GAAG;IAClD;IAEA,OAAO,yBAAyB,YAAY,GAAG;AACjD;AAKO,SAAS,wBACd,UAAuB,EACvB,SAAiB,KAAK,KAAK,KAAK,KAAK,iBAAiB;AAAlB;IAEpC,MAAM,cAAc,WAAW,MAAM,CACnC,CAAA,IAAK,CAAC,MAAM,EAAE,KAAK,KAAK,EAAE,KAAK,KAAK,QAAQ,EAAE,QAAQ,GAAG;IAG3D,IAAI,YAAY,MAAM,KAAK,GAAG;QAC5B,OAAO;IACT;IAEA,oCAAoC;IACpC,MAAM,MAAM,YAAY,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,EAAE,KAAK,EAAE;IAC1D,MAAM,MAAM,MAAM,YAAY,MAAM;IAEpC,OAAO;QAAE,OAAO;QAAK,SAAS;IAAe;AAC/C","debugId":null}},
    {"offset": {"line": 694, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolaskaris/projects/sandbars/lib/forecast/hierarchy.ts"],"sourcesContent":["/**\n * Multi-Source Data Hierarchy Module\n * Implements priority cascade: Primary → Secondary → Tertiary → Model Fallback\n */\n\nimport { QualityFlag, MetricType } from '@/types';\nimport {\n  fetchNDBCBuoyData,\n  findNearestBuoys,\n  NDBCBuoyReading,\n  calculateDistance,\n} from './sources/ndbc';\nimport {\n  fetchNWSForecast,\n  convertNWSToWeatherData,\n  getWeatherAtTime,\n  NWSWeatherData,\n} from './sources/nws';\nimport {\n  fetchTidePredictions,\n  findNearestTideStation,\n  getTideAtTime,\n  TidePrediction,\n} from './sources/tides';\nimport {\n  inverseDistanceWeighting,\n  interpolateWaveData,\n  interpolateWindData,\n  interpolateSlowVariable,\n  DataPoint,\n} from './interpolation';\n\nexport interface MetricValue {\n  value: number | null;\n  quality: QualityFlag;\n  source: string;\n  sourceHierarchy: string[];\n}\n\n/**\n * Get wave height with fallback hierarchy\n * Primary: Nearest NDBC buoy (< 50km)\n * Secondary: Interpolate from 2-3 nearby buoys\n * Tertiary: WaveWatch III model data\n * Fallback: Historical average\n */\nexport async function getWaveHeight(\n  lat: number,\n  lon: number,\n  targetTime?: Date\n): Promise<MetricValue> {\n  const sourceHierarchy: string[] = [];\n\n  // Primary: Try nearest buoy\n  const nearestBuoys = findNearestBuoys(lat, lon, 50, 1);\n  if (nearestBuoys.length > 0) {\n    const buoy = nearestBuoys[0];\n    sourceHierarchy.push(`buoy_${buoy.id}_primary`);\n\n    const buoyData = await fetchNDBCBuoyData(buoy.id);\n    if (buoyData && buoyData.waveHeight !== undefined) {\n      return {\n        value: buoyData.waveHeight,\n        quality: buoyData.quality,\n        source: `NDBC Buoy ${buoy.id} (${buoy.name})`,\n        sourceHierarchy,\n      };\n    }\n  }\n\n  // Secondary: Try interpolation from multiple buoys\n  const nearbyBuoys = findNearestBuoys(lat, lon, 100, 5);\n  if (nearbyBuoys.length >= 2) {\n    sourceHierarchy.push('buoy_interpolation');\n\n    const dataPoints: DataPoint[] = [];\n    for (const buoy of nearbyBuoys) {\n      const buoyData = await fetchNDBCBuoyData(buoy.id);\n      if (buoyData && buoyData.waveHeight !== undefined) {\n        dataPoints.push({\n          value: buoyData.waveHeight,\n          distance: calculateDistance(lat, lon, buoy.lat, buoy.lon),\n          quality: buoyData.quality,\n        });\n      }\n    }\n\n    if (dataPoints.length >= 2) {\n      const distanceToShore = 10; // TODO: Calculate actual distance to shore\n      const interpolated = interpolateWaveData(dataPoints, distanceToShore);\n      if (interpolated) {\n        return {\n          value: interpolated.value,\n          quality: interpolated.quality,\n          source: `Interpolated from ${dataPoints.length} buoys`,\n          sourceHierarchy,\n        };\n      }\n    }\n  }\n\n  // Tertiary: WaveWatch III model (not implemented yet)\n  sourceHierarchy.push('wavewatch_model');\n\n  // Fallback: Use a reasonable default\n  sourceHierarchy.push('fallback');\n  return {\n    value: 1.0, // 1 meter default\n    quality: 'historical',\n    source: 'Historical average',\n    sourceHierarchy,\n  };\n}\n\n/**\n * Get wave period with fallback hierarchy\n */\nexport async function getWavePeriod(\n  lat: number,\n  lon: number,\n  targetTime?: Date\n): Promise<MetricValue> {\n  const sourceHierarchy: string[] = [];\n\n  // Primary: Try nearest buoy\n  const nearestBuoys = findNearestBuoys(lat, lon, 50, 1);\n  if (nearestBuoys.length > 0) {\n    const buoy = nearestBuoys[0];\n    sourceHierarchy.push(`buoy_${buoy.id}_primary`);\n\n    const buoyData = await fetchNDBCBuoyData(buoy.id);\n    if (buoyData && buoyData.dominantWavePeriod !== undefined) {\n      return {\n        value: buoyData.dominantWavePeriod,\n        quality: buoyData.quality,\n        source: `NDBC Buoy ${buoy.id} (${buoy.name})`,\n        sourceHierarchy,\n      };\n    }\n  }\n\n  // Secondary: Interpolation\n  const nearbyBuoys = findNearestBuoys(lat, lon, 100, 5);\n  if (nearbyBuoys.length >= 2) {\n    sourceHierarchy.push('buoy_interpolation');\n\n    const dataPoints: DataPoint[] = [];\n    for (const buoy of nearbyBuoys) {\n      const buoyData = await fetchNDBCBuoyData(buoy.id);\n      const period = buoyData?.dominantWavePeriod || buoyData?.averageWavePeriod;\n      if (period !== undefined) {\n        dataPoints.push({\n          value: period,\n          distance: calculateDistance(lat, lon, buoy.lat, buoy.lon),\n          quality: buoyData?.quality || 'missing',\n        });\n      }\n    }\n\n    if (dataPoints.length >= 2) {\n      const interpolated = inverseDistanceWeighting(dataPoints);\n      if (interpolated) {\n        return {\n          value: interpolated.value,\n          quality: interpolated.quality,\n          source: `Interpolated from ${dataPoints.length} buoys`,\n          sourceHierarchy,\n        };\n      }\n    }\n  }\n\n  // Fallback\n  sourceHierarchy.push('fallback');\n  return {\n    value: 10, // 10 second default\n    quality: 'historical',\n    source: 'Historical average',\n    sourceHierarchy,\n  };\n}\n\n/**\n * Get wave direction with fallback hierarchy\n */\nexport async function getWaveDirection(\n  lat: number,\n  lon: number,\n  windDirection?: number\n): Promise<MetricValue> {\n  const sourceHierarchy: string[] = [];\n\n  // Primary: Try nearest buoy\n  const nearestBuoys = findNearestBuoys(lat, lon, 50, 1);\n  if (nearestBuoys.length > 0) {\n    const buoy = nearestBuoys[0];\n    sourceHierarchy.push(`buoy_${buoy.id}_primary`);\n\n    const buoyData = await fetchNDBCBuoyData(buoy.id);\n    if (buoyData && buoyData.waveDirection !== undefined) {\n      return {\n        value: buoyData.waveDirection,\n        quality: buoyData.quality,\n        source: `NDBC Buoy ${buoy.id} (${buoy.name})`,\n        sourceHierarchy,\n      };\n    }\n  }\n\n  // Fallback to wind direction if available\n  if (windDirection !== undefined) {\n    sourceHierarchy.push('wind_direction_fallback');\n    return {\n      value: windDirection,\n      quality: 'interpolated',\n      source: 'Wind direction',\n      sourceHierarchy,\n    };\n  }\n\n  sourceHierarchy.push('no_data');\n  return {\n    value: null,\n    quality: 'missing',\n    source: 'No data available',\n    sourceHierarchy,\n  };\n}\n\n/**\n * Get air temperature with fallback hierarchy\n * Primary: NWS API point forecast\n * Secondary: Nearest NWS observation station\n * Tertiary: NDBC buoy (if available)\n */\nexport async function getAirTemperature(\n  lat: number,\n  lon: number,\n  targetTime: Date\n): Promise<MetricValue> {\n  const sourceHierarchy: string[] = [];\n\n  // Primary: NWS forecast\n  sourceHierarchy.push('nws_forecast');\n  const nwsForecast = await fetchNWSForecast(lat, lon);\n  if (nwsForecast.length > 0) {\n    const weatherData = convertNWSToWeatherData(nwsForecast);\n    const weather = getWeatherAtTime(weatherData, targetTime);\n    if (weather && weather.airTemperature !== undefined) {\n      return {\n        value: weather.airTemperature,\n        quality: weather.quality,\n        source: 'NOAA NWS Forecast',\n        sourceHierarchy,\n      };\n    }\n  }\n\n  // Tertiary: Try nearby buoys\n  const nearbyBuoys = findNearestBuoys(lat, lon, 100, 3);\n  if (nearbyBuoys.length > 0) {\n    sourceHierarchy.push('buoy_air_temp');\n\n    const dataPoints: DataPoint[] = [];\n    for (const buoy of nearbyBuoys) {\n      const buoyData = await fetchNDBCBuoyData(buoy.id);\n      if (buoyData && buoyData.airTemperature !== undefined) {\n        dataPoints.push({\n          value: buoyData.airTemperature,\n          distance: calculateDistance(lat, lon, buoy.lat, buoy.lon),\n          quality: buoyData.quality,\n        });\n      }\n    }\n\n    if (dataPoints.length > 0) {\n      const interpolated = interpolateSlowVariable(dataPoints);\n      if (interpolated) {\n        return {\n          value: interpolated.value,\n          quality: interpolated.quality,\n          source: `Interpolated from ${dataPoints.length} buoys`,\n          sourceHierarchy,\n        };\n      }\n    }\n  }\n\n  sourceHierarchy.push('no_data');\n  return {\n    value: null,\n    quality: 'missing',\n    source: 'No data available',\n    sourceHierarchy,\n  };\n}\n\n/**\n * Get wind speed and direction from NWS or buoys\n */\nexport async function getWindData(\n  lat: number,\n  lon: number,\n  targetTime: Date\n): Promise<{ speed: MetricValue; direction: MetricValue }> {\n  const sourceHierarchy: string[] = [];\n\n  // Primary: NWS forecast\n  sourceHierarchy.push('nws_forecast');\n  const nwsForecast = await fetchNWSForecast(lat, lon);\n  if (nwsForecast.length > 0) {\n    const weatherData = convertNWSToWeatherData(nwsForecast);\n    const weather = getWeatherAtTime(weatherData, targetTime);\n    if (weather && weather.windSpeed !== undefined && weather.windDirection !== undefined) {\n      return {\n        speed: {\n          value: weather.windSpeed,\n          quality: weather.quality,\n          source: 'NOAA NWS Forecast',\n          sourceHierarchy: [...sourceHierarchy],\n        },\n        direction: {\n          value: weather.windDirection,\n          quality: weather.quality,\n          source: 'NOAA NWS Forecast',\n          sourceHierarchy: [...sourceHierarchy],\n        },\n      };\n    }\n  }\n\n  // Secondary: Buoy interpolation\n  const nearbyBuoys = findNearestBuoys(lat, lon, 100, 5);\n  const speedDataPoints: DataPoint[] = [];\n  const dirDataPoints: DataPoint[] = [];\n\n  for (const buoy of nearbyBuoys) {\n    const buoyData = await fetchNDBCBuoyData(buoy.id);\n    const distance = calculateDistance(lat, lon, buoy.lat, buoy.lon);\n\n    if (buoyData && buoyData.windSpeed !== undefined) {\n      speedDataPoints.push({\n        value: buoyData.windSpeed,\n        distance,\n        quality: buoyData.quality,\n      });\n    }\n\n    if (buoyData && buoyData.windDirection !== undefined) {\n      dirDataPoints.push({\n        value: buoyData.windDirection,\n        distance,\n        quality: buoyData.quality,\n      });\n    }\n  }\n\n  const distanceToShore = 10; // TODO: Calculate actual\n  const speedInterp = interpolateWindData(speedDataPoints, distanceToShore);\n  const dirInterp = interpolateWindData(dirDataPoints, distanceToShore);\n\n  return {\n    speed: speedInterp\n      ? {\n          value: speedInterp.value,\n          quality: speedInterp.quality,\n          source: `Interpolated from ${speedDataPoints.length} buoys`,\n          sourceHierarchy: [...sourceHierarchy, 'buoy_interpolation'],\n        }\n      : { value: 5, quality: 'historical', source: 'Default', sourceHierarchy: [...sourceHierarchy, 'fallback'] },\n    direction: dirInterp\n      ? {\n          value: dirInterp.value,\n          quality: dirInterp.quality,\n          source: `Interpolated from ${dirDataPoints.length} buoys`,\n          sourceHierarchy: [...sourceHierarchy, 'buoy_interpolation'],\n        }\n      : { value: null, quality: 'missing', source: 'No data', sourceHierarchy: [...sourceHierarchy, 'no_data'] },\n  };\n}\n\n/**\n * Get water temperature from buoys\n */\nexport async function getWaterTemperature(lat: number, lon: number): Promise<MetricValue> {\n  const sourceHierarchy: string[] = [];\n\n  // Try nearby buoys\n  const nearbyBuoys = findNearestBuoys(lat, lon, 100, 5);\n  const dataPoints: DataPoint[] = [];\n\n  for (const buoy of nearbyBuoys) {\n    sourceHierarchy.push(`buoy_${buoy.id}`);\n    const buoyData = await fetchNDBCBuoyData(buoy.id);\n    if (buoyData && buoyData.waterTemperature !== undefined) {\n      dataPoints.push({\n        value: buoyData.waterTemperature,\n        distance: calculateDistance(lat, lon, buoy.lat, buoy.lon),\n        quality: buoyData.quality,\n      });\n    }\n  }\n\n  if (dataPoints.length > 0) {\n    const interpolated = interpolateSlowVariable(dataPoints);\n    if (interpolated) {\n      return {\n        value: interpolated.value,\n        quality: interpolated.quality,\n        source: `Interpolated from ${dataPoints.length} buoys`,\n        sourceHierarchy,\n      };\n    }\n  }\n\n  sourceHierarchy.push('no_data');\n  return {\n    value: null,\n    quality: 'missing',\n    source: 'No data available',\n    sourceHierarchy,\n  };\n}\n\n/**\n * Get tide level\n */\nexport async function getTideLevel(\n  lat: number,\n  lon: number,\n  targetTime: Date\n): Promise<MetricValue> {\n  const sourceHierarchy: string[] = [];\n\n  const tideStation = findNearestTideStation(lat, lon);\n  if (!tideStation) {\n    return {\n      value: null,\n      quality: 'missing',\n      source: 'No tide station nearby',\n      sourceHierarchy: ['no_station'],\n    };\n  }\n\n  sourceHierarchy.push(`tide_station_${tideStation.id}`);\n\n  // Fetch 24 hours of predictions\n  const startTime = new Date(targetTime);\n  startTime.setHours(startTime.getHours() - 12);\n  const endTime = new Date(targetTime);\n  endTime.setHours(endTime.getHours() + 12);\n\n  const predictions = await fetchTidePredictions(tideStation.id, startTime, endTime);\n  const tidePrediction = getTideAtTime(predictions, targetTime);\n\n  if (tidePrediction) {\n    return {\n      value: tidePrediction.tideLevel,\n      quality: tidePrediction.quality,\n      source: `NOAA Tide Station ${tideStation.name}`,\n      sourceHierarchy,\n    };\n  }\n\n  sourceHierarchy.push('no_data');\n  return {\n    value: null,\n    quality: 'missing',\n    source: 'No tide data available',\n    sourceHierarchy,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1085, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolaskaris/projects/sandbars/lib/forecast/calculations.ts"],"sourcesContent":["/**\n * Calculations Module\n * Derived metrics like wave power\n */\n\n/**\n * Calculate wave power\n * Formula: P = 0.5 * ρ * g * H² * T\n * Where:\n *   ρ (rho) = water density = 1025 kg/m³ (seawater)\n *   g = gravitational acceleration = 9.81 m/s²\n *   H = significant wave height (meters)\n *   T = wave period (seconds)\n *\n * @param waveHeight - Significant wave height in meters\n * @param wavePeriod - Wave period in seconds\n * @returns Wave power in kW/m\n */\nexport function calculateWavePower(waveHeight: number, wavePeriod: number): number {\n  const RHO = 1025; // kg/m³ - seawater density\n  const G = 9.81; // m/s² - gravitational acceleration\n\n  // P = 0.5 * ρ * g * H² * T\n  const power = 0.5 * RHO * G * Math.pow(waveHeight, 2) * wavePeriod;\n\n  // Convert to kW/m\n  return power / 1000;\n}\n\n/**\n * Calculate wave energy flux (similar to power but more precise)\n * Formula: E = (ρ * g² / 64π) * H² * T\n *\n * @param waveHeight - Significant wave height in meters\n * @param wavePeriod - Wave period in seconds\n * @returns Wave energy flux in kW/m\n */\nexport function calculateWaveEnergyFlux(waveHeight: number, wavePeriod: number): number {\n  const RHO = 1025; // kg/m³\n  const G = 9.81; // m/s²\n\n  // E = (ρ * g² / 64π) * H² * T\n  const energy = ((RHO * Math.pow(G, 2)) / (64 * Math.PI)) * Math.pow(waveHeight, 2) * wavePeriod;\n\n  // Convert to kW/m\n  return energy / 1000;\n}\n\n/**\n * Estimate surf quality based on wave metrics\n * Returns a score from 0-10\n */\nexport function calculateSurfQualityScore(\n  waveHeight: number,\n  wavePeriod: number,\n  windSpeed: number,\n  windDirection?: number,\n  waveDirection?: number\n): number {\n  let score = 0;\n\n  // Wave height score (0-3 points)\n  // Optimal: 1-2.5m\n  if (waveHeight >= 1 && waveHeight <= 2.5) {\n    score += 3;\n  } else if (waveHeight >= 0.6 && waveHeight < 1) {\n    score += 2;\n  } else if (waveHeight > 2.5 && waveHeight <= 3.5) {\n    score += 2;\n  } else if (waveHeight > 0.3 && waveHeight < 0.6) {\n    score += 1;\n  }\n\n  // Wave period score (0-3 points)\n  // Optimal: 10-16 seconds (long period swells)\n  if (wavePeriod >= 10 && wavePeriod <= 16) {\n    score += 3;\n  } else if (wavePeriod >= 8 && wavePeriod < 10) {\n    score += 2;\n  } else if (wavePeriod > 16 && wavePeriod <= 20) {\n    score += 2;\n  } else if (wavePeriod >= 6 && wavePeriod < 8) {\n    score += 1;\n  }\n\n  // Wind score (0-2 points)\n  // Optimal: light offshore wind (< 5 m/s)\n  if (windSpeed < 3) {\n    score += 2;\n  } else if (windSpeed < 5) {\n    score += 1.5;\n  } else if (windSpeed < 8) {\n    score += 1;\n  } else if (windSpeed < 12) {\n    score += 0.5;\n  }\n\n  // Wind/wave direction score (0-2 points)\n  if (windDirection !== undefined && waveDirection !== undefined) {\n    const directionDiff = Math.abs(windDirection - waveDirection);\n    const normalizedDiff = Math.min(directionDiff, 360 - directionDiff);\n\n    // Offshore wind (wind opposite to waves) is best\n    if (normalizedDiff > 150 && normalizedDiff < 210) {\n      score += 2;\n    } else if (normalizedDiff > 120 && normalizedDiff < 240) {\n      score += 1.5;\n    } else if (normalizedDiff < 30) {\n      // Onshore wind (same direction as waves) is bad\n      score += 0;\n    } else {\n      score += 1;\n    }\n  }\n\n  return Math.min(score, 10);\n}\n\n/**\n * Convert wind speed from various units\n */\nexport function convertWindSpeed(\n  value: number,\n  from: 'mph' | 'knots' | 'ms' | 'kmh',\n  to: 'ms' = 'ms'\n): number {\n  // Convert to m/s first\n  let ms: number;\n  switch (from) {\n    case 'mph':\n      ms = value * 0.44704;\n      break;\n    case 'knots':\n      ms = value * 0.514444;\n      break;\n    case 'kmh':\n      ms = value / 3.6;\n      break;\n    case 'ms':\n    default:\n      ms = value;\n  }\n\n  return ms;\n}\n\n/**\n * Convert temperature\n */\nexport function convertTemperature(\n  value: number,\n  from: 'C' | 'F',\n  to: 'C' | 'F' = 'C'\n): number {\n  if (from === to) return value;\n\n  if (from === 'F' && to === 'C') {\n    return ((value - 32) * 5) / 9;\n  } else {\n    return (value * 9) / 5 + 32;\n  }\n}\n\n/**\n * Estimate breaking wave height based on depth\n * Waves typically break when H/d ≈ 0.78 (where d is water depth)\n */\nexport function estimateBreakingWaveHeight(depth: number): number {\n  return depth * 0.78;\n}\n\n/**\n * Calculate wave celerity (phase speed)\n * C = L/T where L is wavelength, T is period\n * Deep water approximation: C = gT/(2π)\n */\nexport function calculateWaveCelerity(wavePeriod: number): number {\n  const G = 9.81; // m/s²\n  return (G * wavePeriod) / (2 * Math.PI);\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1223, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolaskaris/projects/sandbars/lib/forecast/index.ts"],"sourcesContent":["/**\n * Main Forecast API\n * Provides unified interface with three-tier caching\n */\n\nimport { EnhancedSurfForecast, CompiledForecastData, StationUsed, QualityFlag } from '@/types';\nimport {\n  getWaveHeight,\n  getWavePeriod,\n  getWaveDirection,\n  getAirTemperature,\n  getWindData,\n  getWaterTemperature,\n  getTideLevel,\n  MetricValue,\n} from './hierarchy';\nimport { calculateWavePower } from './calculations';\nimport { findNearestBuoys } from './sources/ndbc';\nimport { findNearestTideStation } from './sources/tides';\n\n/**\n * Get comprehensive surf forecast for a location\n * Implements three-tier caching strategy:\n * 1. Check location cache (30 min TTL)\n * 2. Fetch from sources with individual caching\n * 3. Compile and cache result\n */\nexport async function getSurfForecast(\n  lat: number,\n  lng: number,\n  hours: number = 168 // 7 days default\n): Promise<CompiledForecastData> {\n  console.log(`Fetching surf forecast for ${lat}, ${lng} - ${hours} hours`);\n\n  const forecasts: EnhancedSurfForecast[] = [];\n  const now = new Date();\n\n  // Track which stations we used\n  const stationsUsed: StationUsed[] = [];\n  const buoys = findNearestBuoys(lat, lng, 200, 5);\n  const tideStation = findNearestTideStation(lat, lng);\n\n  for (const buoy of buoys) {\n    if (!stationsUsed.find(s => s.station_id === buoy.id)) {\n      stationsUsed.push({\n        station_id: buoy.id,\n        type: 'buoy',\n        name: buoy.name,\n        distance_km: Math.round(\n          calculateDistance(lat, lng, buoy.lat, buoy.lon)\n        ),\n        metrics: [\n          'wave_height',\n          'wave_period',\n          'wave_direction',\n          'wind_speed',\n          'wind_direction',\n          'water_temperature',\n        ],\n      });\n    }\n  }\n\n  if (tideStation) {\n    stationsUsed.push({\n      station_id: tideStation.id,\n      type: 'tide',\n      name: tideStation.name,\n      distance_km: Math.round(\n        calculateDistance(lat, lng, tideStation.lat, tideStation.lon)\n      ),\n      metrics: ['tide_level'],\n    });\n  }\n\n  // Generate hourly forecasts\n  for (let i = 0; i < hours; i++) {\n    const forecastTime = new Date(now.getTime() + i * 3600000);\n\n    try {\n      // Fetch all metrics in parallel\n      const [\n        waveHeight,\n        wavePeriod,\n        windData,\n        waveDirection,\n        waterTemp,\n        airTemp,\n        tideLevel,\n      ] = await Promise.all([\n        getWaveHeight(lat, lng, forecastTime),\n        getWavePeriod(lat, lng, forecastTime),\n        getWindData(lat, lng, forecastTime),\n        getWaveDirection(lat, lng),\n        getWaterTemperature(lat, lng),\n        getAirTemperature(lat, lng, forecastTime),\n        getTideLevel(lat, lng, forecastTime),\n      ]);\n\n      // Use wind direction if wave direction not available\n      const finalWaveDirection = waveDirection.value !== null\n        ? waveDirection\n        : windData.direction.value !== null\n        ? windData.direction\n        : null;\n\n      // Calculate wave power if we have the required data\n      let wavePowerMetric: { value: number; quality: QualityFlag } | undefined;\n      if (waveHeight.value !== null && wavePeriod.value !== null) {\n        const power = calculateWavePower(waveHeight.value, wavePeriod.value);\n        wavePowerMetric = {\n          value: power,\n          quality: combineQuality(waveHeight.quality, wavePeriod.quality),\n        };\n      }\n\n      const forecast: EnhancedSurfForecast = {\n        time: forecastTime.toISOString(),\n        waveHeight: {\n          min: waveHeight.value !== null ? waveHeight.value * 0.8 : 0.5,\n          max: waveHeight.value !== null ? waveHeight.value * 1.2 : 1.5,\n          quality: waveHeight.quality,\n        },\n        wavePeriod: {\n          value: wavePeriod.value || 10,\n          quality: wavePeriod.quality,\n        },\n        waveDirection: finalWaveDirection\n          ? {\n              value: finalWaveDirection.value!,\n              quality: finalWaveDirection.quality,\n            }\n          : undefined,\n        wavePower: wavePowerMetric,\n        windSpeed: {\n          value: windData.speed.value || 5,\n          quality: windData.speed.quality,\n        },\n        windDirection: windData.direction.value !== null\n          ? {\n              value: windData.direction.value,\n              quality: windData.direction.quality,\n            }\n          : undefined,\n        waterTemperature: waterTemp.value !== null\n          ? {\n              value: waterTemp.value,\n              quality: waterTemp.quality,\n            }\n          : undefined,\n        airTemperature: airTemp.value !== null\n          ? {\n              value: airTemp.value,\n              quality: airTemp.quality,\n            }\n          : undefined,\n        tideLevel: tideLevel.value !== null\n          ? {\n              value: tideLevel.value,\n              quality: tideLevel.quality,\n            }\n          : undefined,\n      };\n\n      forecasts.push(forecast);\n    } catch (error) {\n      console.error(`Error generating forecast for hour ${i}:`, error);\n    }\n  }\n\n  // Calculate metadata\n  const qualityCounts = forecasts.reduce(\n    (acc, f) => {\n      if (f.waveHeight.quality === 'primary') acc.primary++;\n      if (f.waveHeight.quality === 'interpolated') acc.interpolated++;\n      if (f.waveHeight.quality === 'modeled') acc.modeled++;\n      return acc;\n    },\n    { primary: 0, interpolated: 0, modeled: 0 }\n  );\n\n  return {\n    forecasts,\n    metadata: {\n      generated_at: new Date().toISOString(),\n      primary_sources: qualityCounts.primary,\n      interpolated_sources: qualityCounts.interpolated,\n      modeled_sources: qualityCounts.modeled,\n    },\n  };\n}\n\n/**\n * Combine quality flags (take the worse of two)\n */\nfunction combineQuality(q1: QualityFlag, q2: QualityFlag): QualityFlag {\n  const hierarchy: QualityFlag[] = [\n    'primary',\n    'interpolated',\n    'modeled',\n    'stale',\n    'historical',\n    'missing',\n  ];\n\n  const idx1 = hierarchy.indexOf(q1);\n  const idx2 = hierarchy.indexOf(q2);\n\n  return hierarchy[Math.max(idx1, idx2)];\n}\n\n/**\n * Calculate distance between coordinates (Haversine)\n */\nfunction calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6371; // km\n  const dLat = toRad(lat2 - lat1);\n  const dLon = toRad(lon2 - lon1);\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n}\n\nfunction toRad(degrees: number): number {\n  return degrees * (Math.PI / 180);\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AAGD;AAUA;AACA;AACA;;;;;AASO,eAAe,gBACpB,GAAW,EACX,GAAW,EACX,QAAgB,IAAI,iBAAiB;AAAlB;IAEnB,QAAQ,GAAG,CAAC,CAAC,2BAA2B,EAAE,IAAI,EAAE,EAAE,IAAI,GAAG,EAAE,MAAM,MAAM,CAAC;IAExE,MAAM,YAAoC,EAAE;IAC5C,MAAM,MAAM,IAAI;IAEhB,+BAA+B;IAC/B,MAAM,eAA8B,EAAE;IACtC,MAAM,QAAQ,IAAA,wJAAgB,EAAC,KAAK,KAAK,KAAK;IAC9C,MAAM,cAAc,IAAA,+JAAsB,EAAC,KAAK;IAEhD,KAAK,MAAM,QAAQ,MAAO;QACxB,IAAI,CAAC,aAAa,IAAI,CAAC,CAAA,IAAK,EAAE,UAAU,KAAK,KAAK,EAAE,GAAG;YACrD,aAAa,IAAI,CAAC;gBAChB,YAAY,KAAK,EAAE;gBACnB,MAAM;gBACN,MAAM,KAAK,IAAI;gBACf,aAAa,KAAK,KAAK,CACrB,kBAAkB,KAAK,KAAK,KAAK,GAAG,EAAE,KAAK,GAAG;gBAEhD,SAAS;oBACP;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;YACH;QACF;IACF;IAEA,IAAI,aAAa;QACf,aAAa,IAAI,CAAC;YAChB,YAAY,YAAY,EAAE;YAC1B,MAAM;YACN,MAAM,YAAY,IAAI;YACtB,aAAa,KAAK,KAAK,CACrB,kBAAkB,KAAK,KAAK,YAAY,GAAG,EAAE,YAAY,GAAG;YAE9D,SAAS;gBAAC;aAAa;QACzB;IACF;IAEA,4BAA4B;IAC5B,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;QAC9B,MAAM,eAAe,IAAI,KAAK,IAAI,OAAO,KAAK,IAAI;QAElD,IAAI;YACF,gCAAgC;YAChC,MAAM,CACJ,YACA,YACA,UACA,eACA,WACA,SACA,UACD,GAAG,MAAM,QAAQ,GAAG,CAAC;gBACpB,IAAA,+IAAa,EAAC,KAAK,KAAK;gBACxB,IAAA,+IAAa,EAAC,KAAK,KAAK;gBACxB,IAAA,6IAAW,EAAC,KAAK,KAAK;gBACtB,IAAA,kJAAgB,EAAC,KAAK;gBACtB,IAAA,qJAAmB,EAAC,KAAK;gBACzB,IAAA,mJAAiB,EAAC,KAAK,KAAK;gBAC5B,IAAA,8IAAY,EAAC,KAAK,KAAK;aACxB;YAED,qDAAqD;YACrD,MAAM,qBAAqB,cAAc,KAAK,KAAK,OAC/C,gBACA,SAAS,SAAS,CAAC,KAAK,KAAK,OAC7B,SAAS,SAAS,GAClB;YAEJ,oDAAoD;YACpD,IAAI;YACJ,IAAI,WAAW,KAAK,KAAK,QAAQ,WAAW,KAAK,KAAK,MAAM;gBAC1D,MAAM,QAAQ,IAAA,uJAAkB,EAAC,WAAW,KAAK,EAAE,WAAW,KAAK;gBACnE,kBAAkB;oBAChB,OAAO;oBACP,SAAS,eAAe,WAAW,OAAO,EAAE,WAAW,OAAO;gBAChE;YACF;YAEA,MAAM,WAAiC;gBACrC,MAAM,aAAa,WAAW;gBAC9B,YAAY;oBACV,KAAK,WAAW,KAAK,KAAK,OAAO,WAAW,KAAK,GAAG,MAAM;oBAC1D,KAAK,WAAW,KAAK,KAAK,OAAO,WAAW,KAAK,GAAG,MAAM;oBAC1D,SAAS,WAAW,OAAO;gBAC7B;gBACA,YAAY;oBACV,OAAO,WAAW,KAAK,IAAI;oBAC3B,SAAS,WAAW,OAAO;gBAC7B;gBACA,eAAe,qBACX;oBACE,OAAO,mBAAmB,KAAK;oBAC/B,SAAS,mBAAmB,OAAO;gBACrC,IACA;gBACJ,WAAW;gBACX,WAAW;oBACT,OAAO,SAAS,KAAK,CAAC,KAAK,IAAI;oBAC/B,SAAS,SAAS,KAAK,CAAC,OAAO;gBACjC;gBACA,eAAe,SAAS,SAAS,CAAC,KAAK,KAAK,OACxC;oBACE,OAAO,SAAS,SAAS,CAAC,KAAK;oBAC/B,SAAS,SAAS,SAAS,CAAC,OAAO;gBACrC,IACA;gBACJ,kBAAkB,UAAU,KAAK,KAAK,OAClC;oBACE,OAAO,UAAU,KAAK;oBACtB,SAAS,UAAU,OAAO;gBAC5B,IACA;gBACJ,gBAAgB,QAAQ,KAAK,KAAK,OAC9B;oBACE,OAAO,QAAQ,KAAK;oBACpB,SAAS,QAAQ,OAAO;gBAC1B,IACA;gBACJ,WAAW,UAAU,KAAK,KAAK,OAC3B;oBACE,OAAO,UAAU,KAAK;oBACtB,SAAS,UAAU,OAAO;gBAC5B,IACA;YACN;YAEA,UAAU,IAAI,CAAC;QACjB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,mCAAmC,EAAE,EAAE,CAAC,CAAC,EAAE;QAC5D;IACF;IAEA,qBAAqB;IACrB,MAAM,gBAAgB,UAAU,MAAM,CACpC,CAAC,KAAK;QACJ,IAAI,EAAE,UAAU,CAAC,OAAO,KAAK,WAAW,IAAI,OAAO;QACnD,IAAI,EAAE,UAAU,CAAC,OAAO,KAAK,gBAAgB,IAAI,YAAY;QAC7D,IAAI,EAAE,UAAU,CAAC,OAAO,KAAK,WAAW,IAAI,OAAO;QACnD,OAAO;IACT,GACA;QAAE,SAAS;QAAG,cAAc;QAAG,SAAS;IAAE;IAG5C,OAAO;QACL;QACA,UAAU;YACR,cAAc,IAAI,OAAO,WAAW;YACpC,iBAAiB,cAAc,OAAO;YACtC,sBAAsB,cAAc,YAAY;YAChD,iBAAiB,cAAc,OAAO;QACxC;IACF;AACF;AAEA;;CAEC,GACD,SAAS,eAAe,EAAe,EAAE,EAAe;IACtD,MAAM,YAA2B;QAC/B;QACA;QACA;QACA;QACA;QACA;KACD;IAED,MAAM,OAAO,UAAU,OAAO,CAAC;IAC/B,MAAM,OAAO,UAAU,OAAO,CAAC;IAE/B,OAAO,SAAS,CAAC,KAAK,GAAG,CAAC,MAAM,MAAM;AACxC;AAEA;;CAEC,GACD,SAAS,kBAAkB,IAAY,EAAE,IAAY,EAAE,IAAY,EAAE,IAAY;IAC/E,MAAM,IAAI,MAAM,KAAK;IACrB,MAAM,OAAO,MAAM,OAAO;IAC1B,MAAM,OAAO,MAAM,OAAO;IAC1B,MAAM,IACJ,KAAK,GAAG,CAAC,OAAO,KAAK,KAAK,GAAG,CAAC,OAAO,KACrC,KAAK,GAAG,CAAC,MAAM,SAAS,KAAK,GAAG,CAAC,MAAM,SAAS,KAAK,GAAG,CAAC,OAAO,KAAK,KAAK,GAAG,CAAC,OAAO;IACvF,MAAM,IAAI,IAAI,KAAK,KAAK,CAAC,KAAK,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI;IACrD,OAAO,IAAI;AACb;AAEA,SAAS,MAAM,OAAe;IAC5B,OAAO,UAAU,CAAC,KAAK,EAAE,GAAG,GAAG;AACjC","debugId":null}},
    {"offset": {"line": 1402, "column": 0}, "map": {"version":3,"sources":["file:///Users/nikolaskaris/projects/sandbars/app/api/forecast/route.ts"],"sourcesContent":["import { createClient } from '@/lib/supabase/server';\nimport { getSurfForecast } from '@/lib/forecast';\nimport { SurfForecast, EnhancedSurfForecast } from '@/types';\nimport { NextResponse } from 'next/server';\n\n/**\n * Convert enhanced forecast to legacy format for backwards compatibility\n */\nfunction toLegacyFormat(enhanced: EnhancedSurfForecast): SurfForecast {\n  return {\n    time: enhanced.time,\n    waveHeight: {\n      min: enhanced.waveHeight.min,\n      max: enhanced.waveHeight.max,\n    },\n    wavePeriod: enhanced.wavePeriod.value,\n    waveDirection: enhanced.waveDirection?.value,\n    windSpeed: enhanced.windSpeed.value,\n    windDirection: enhanced.windDirection?.value,\n    waterTemperature: enhanced.waterTemperature?.value,\n    airTemperature: enhanced.airTemperature?.value,\n    wavePower: enhanced.wavePower?.value,\n  };\n}\n\nexport async function GET(request: Request) {\n  try {\n    const supabase = await createClient();\n\n    const { data: { user }, error: userError } = await supabase.auth.getUser();\n\n    if (userError || !user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { searchParams } = new URL(request.url);\n    const lat = parseFloat(searchParams.get('lat') || '');\n    const lng = parseFloat(searchParams.get('lng') || '');\n    const enhanced = searchParams.get('enhanced') === 'true'; // Optional: return enhanced format\n    const hours = parseInt(searchParams.get('hours') || '168'); // Default 7 days\n\n    if (isNaN(lat) || isNaN(lng)) {\n      return NextResponse.json(\n        { error: 'Invalid coordinates' },\n        { status: 400 }\n      );\n    }\n\n    const forecastData = await getSurfForecast(lat, lng, hours);\n\n    // Return enhanced format with metadata, or legacy format\n    if (enhanced) {\n      return NextResponse.json(forecastData);\n    } else {\n      // Convert to legacy format for backwards compatibility\n      const legacyForecasts = forecastData.forecasts.map(toLegacyFormat);\n      return NextResponse.json(legacyForecasts);\n    }\n  } catch (error) {\n    console.error('Forecast API error:', error);\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Failed to fetch forecast' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAEA;;;;AAEA;;CAEC,GACD,SAAS,eAAe,QAA8B;IACpD,OAAO;QACL,MAAM,SAAS,IAAI;QACnB,YAAY;YACV,KAAK,SAAS,UAAU,CAAC,GAAG;YAC5B,KAAK,SAAS,UAAU,CAAC,GAAG;QAC9B;QACA,YAAY,SAAS,UAAU,CAAC,KAAK;QACrC,eAAe,SAAS,aAAa,EAAE;QACvC,WAAW,SAAS,SAAS,CAAC,KAAK;QACnC,eAAe,SAAS,aAAa,EAAE;QACvC,kBAAkB,SAAS,gBAAgB,EAAE;QAC7C,gBAAgB,SAAS,cAAc,EAAE;QACzC,WAAW,SAAS,SAAS,EAAE;IACjC;AACF;AAEO,eAAe,IAAI,OAAgB;IACxC,IAAI;QACF,MAAM,WAAW,MAAM,IAAA,2IAAY;QAEnC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,OAAO,SAAS,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;QAExE,IAAI,aAAa,CAAC,MAAM;YACtB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,MAAM,WAAW,aAAa,GAAG,CAAC,UAAU;QAClD,MAAM,MAAM,WAAW,aAAa,GAAG,CAAC,UAAU;QAClD,MAAM,WAAW,aAAa,GAAG,CAAC,gBAAgB,QAAQ,mCAAmC;QAC7F,MAAM,QAAQ,SAAS,aAAa,GAAG,CAAC,YAAY,QAAQ,iBAAiB;QAE7E,IAAI,MAAM,QAAQ,MAAM,MAAM;YAC5B,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAsB,GAC/B;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,eAAe,MAAM,IAAA,6IAAe,EAAC,KAAK,KAAK;QAErD,yDAAyD;QACzD,IAAI,UAAU;YACZ,OAAO,gJAAY,CAAC,IAAI,CAAC;QAC3B,OAAO;YACL,uDAAuD;YACvD,MAAM,kBAAkB,aAAa,SAAS,CAAC,GAAG,CAAC;YACnD,OAAO,gJAAY,CAAC,IAAI,CAAC;QAC3B;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uBAAuB;QACrC,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAA2B,GAC7E;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}